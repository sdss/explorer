"""Utility functions for generating plot objects and calculations"""

import json
from typing import Optional, Callable, Any

from bokeh.core.properties import DataSpec
from bokeh.models.grids import Grid
from bokeh.models.plots import Plot
from bokeh.models.ranges import DataRange1d
from bokeh.plotting import ColumnDataSource
import numpy as np
import vaex as vx
from bokeh.models.scales import LinearScale, LogScale
from bokeh.models.tools import (
    BoxSelectTool,
    BoxZoomTool,
    CustomJSHover,
    LassoSelectTool,
    SaveTool,
    WheelZoomTool,
    HoverTool,
    ExamineTool,
    PanTool,
    ResetTool,
    TapTool,
)
from bokeh.models.mappers import (
    LinearColorMapper,
    LogColorMapper,
    CategoricalColorMapper,
)
from bokeh.models.formatters import (
    CustomJSTickFormatter, )
from bokeh.models import CustomJS, ColorBar, BasicTicker, FixedTicker
from bokeh.models.ui import ActionItem, Menu as BokehMenu
from bokeh.models.axes import LinearAxis
from bokeh.model import Model
from bokeh.transform import factor_cmap, linear_cmap, log_cmap

from util import check_categorical
from state import PlotState

DEV = True  # TODO: switch to read envvar


def add_all_tools(p: Plot, tooltips: Optional[str] = None) -> list[Model]:
    """Adds all basic tools, modifies plot's toolbar."""
    # create hovertool
    hover = HoverTool(
        tooltips=tooltips,
        visible=False,
    )

    # generate other tools
    pan = PanTool()
    boxzoom = BoxZoomTool()
    wz = WheelZoomTool()
    box_select = BoxSelectTool()
    lasoo = LassoSelectTool()
    reset = ResetTool()
    save = SaveTool()
    tools = [pan, boxzoom, box_select, lasoo, hover, wz, save, reset]

    if DEV:
        tools.append(ExamineTool())  # debugging tool
    p.add_tools(*tools)
    p.toolbar.active_scroll = wz  # sets scroll wheelzoom
    p.toolbar.autohide = True  # hide when not hovered

    return tools


def add_axes(plotstate: PlotState, p: Plot) -> None:
    """Generates axes and corresponding grids for plots, modifies object inplace.

    Args:
        plotstate: plot variables
        p: figure

    """
    xaxis = LinearAxis(axis_label=generate_label(plotstate, "x"))
    yaxis = LinearAxis(axis_label=generate_label(plotstate, "y"))
    grid_x = Grid(dimension=0, ticker=xaxis.ticker, visible=True)
    grid_y = Grid(dimension=1, ticker=yaxis.ticker, visible=True)
    p.add_layout(xaxis, "below")
    p.add_layout(yaxis, "left")
    p.add_layout(grid_x, "center")
    p.add_layout(grid_y, "center")


def generate_plot():
    """Generates basic plot object with context menu, with object bindings."""
    # create menu
    menu = BokehMenu()
    menu.styles = {"color": "black", "font-size": "16px"}

    # generate main Plot model
    # NOTE: if you change default viewcard height, this must also change
    p = Plot(
        context_menu=menu,
        toolbar_location="above",
        height=360,
        height_policy=
        "fixed",  # do what we tell you and don't try to go find bounds
        # height_policy=
        # "fit",  # NOTE: this doesn't work in the Lumino context of the cards
        width_policy="max",
        reset_policy=
        "event_only",  # NOTE: we handle resets ourselves bc changing scales crashes it
        output_backend=
        "webgl",  # for performance, will fallback to HTML5 if unsupported
        lod_factor=20000,
        lod_interval=300,
        lod_threshold=1000,
        lod_timeout=10000,
    )
    name = "menu-propogate"
    items = [
        ActionItem(label="Clear selection", disabled=True, name="menu-clear"),
        ActionItem(
            label="Reset plot",
            name="reset-view",
            action=CustomJS(args=dict(p=p), code="""p.reset.emit()"""),
        ),
    ]
    menu.update(items=items)

    # add extra ranges
    # NOTE: categorical swaps aren't supported, so we do server-side mapping
    p.extra_x_scales = {
        "lin": LinearScale(),
        "log": LogScale(),
    }
    p.extra_y_scales = {
        "lin": LinearScale(),
        "log": LogScale(),
    }
    p.extra_x_ranges = {
        "lin": DataRange1d(),
        "log": DataRange1d(),
    }
    p.extra_y_ranges = {
        "lin": DataRange1d(),
        "log": DataRange1d(),
    }

    return p, menu


def add_colorbar(plotstate: PlotState, p: Plot,
                 color_mapper: LinearColorMapper, data) -> None:
    """Adds a colorbar to plot. Used during initialization.

    Args:
        plotstate: plot variables
        p: figure
        fill_color: fill color dictionary, generated by `generate_color_mapper`

    """
    cb = ColorBar(
        color_mapper=color_mapper,  # color_mapper object
        ticker=FixedTicker(
            ticks=calculate_colorbar_ticks(np.nanmin(data), np.nanmax(data))),
        location=(5, 6),
        title=generate_label(plotstate, axis="color"),
    )
    p.add_layout(cb, "right")


def _calculate_color_range(
        plotstate: PlotState,
        color: Optional[np.ndarray] = None) -> tuple[float, float]:
    """Calculates low/high for colormapper.

    Args:
        plotstate: plot variables
        color: optional pre-computed aggregation data.
    """
    from state import df  # TODO: get for subset

    col = plotstate.color.value

    if color is None:
        expr = df[col]  # NOTE: we compile for global df for true minmax
    else:
        expr = color

    if plotstate.plottype == "heatmap":
        assert color is not None, "expected color handoff but got nothing"
        assert not check_categorical(
            col), "handed categorical data for aggregation"
        bintype = getattr(plotstate, "bintype")
        if bintype == "count":
            low = 0
        else:
            low = np.nanmin(expr)
        high = np.nanmax(expr)
    else:
        assert color is None, f"expected no color handoff but got {color}"
        if check_categorical(col):
            # NOTE: colormapping must be updated before this
            low = 0
            high = len(plotstate.colormapping) - 1
        else:
            if plotstate.logcolor.value:
                expr = df[df[col] > 0][col]
            low = expr.min()[()]
            high = expr.max()[()]
    return low, high


def generate_color_mapper(plotstate: PlotState,
                          z: Optional[np.ndarray] = None) -> LinearColorMapper:
    """Create a colormapper.

    Args:
        plotstate: plot variables
        z: pre-computed aggregated data array.
    """
    low, high = _calculate_color_range(plotstate, z)

    return LinearColorMapper(
        palette=plotstate.colorscale.value,
        low=low,
        high=high,
    )


def generate_label(plotstate: PlotState, axis: str = "x") -> str:
    """Generates an axis label.

    Args:
        plotstate: plot variables
        axis: which axis to generate a label for. Any of ('x', 'y', or 'color')

    Returns:
        A formatted, pretty axis label
    """
    assert axis in ("x", "y", "color")
    col = getattr(plotstate, axis).value
    log = getattr(plotstate,
                  "logcolor" if axis == "color" else f"log{axis}").value
    cond = log and not check_categorical(col)
    if (axis == "color") and (plotstate.plottype == "heatmap"):
        bintype = getattr(plotstate, "bintype").value
        bincond = (bintype != "count") and (bintype != "")
        if bintype == "count":
            # no col data if just counting
            col = ""
    else:
        bintype = ""
        bincond = False

    # very long oneliner
    return f"{'log(' if cond else ''}{bintype}{'(' if bincond else ''}{col}{')' if bincond else ''}{')' if cond else ''}"


def add_callbacks(
    plotstate: PlotState,
    dff: vx.DataFrame,
    p: Plot,
    source: ColumnDataSource,
    set_filter: Optional[Callable[[Any], Any]] = None,
) -> None:
    """
    Adds various callbacks, for filtering, context menu, and resets.

    Args:
        plotstate: plot variables
        dff: filtered dataframe
        p: figure
        source: data source object
        set_filter: filter setter function
    """
    # grab via names set in generate_plot
    item = p.select(name="menu-clear")[0]
    item.action = CustomJS(
        args=dict(source=source),
        code="""
             source.selected.indices = [];
             source.change.emit();
             """,
    )

    # selection callback to disable/enable these items
    def on_select(attr, old, new):
        if len(new) == 0:
            # disable button
            item.update(disabled=True)
        else:
            item.update(disabled=False)

    source.selected.on_change("indices", on_select)

    # selection callback to update the filter object
    if set_filter is not None:  # TODO: remove this line make non optional

        def propogate_select_to_filter(attr, old, new):
            if len(new) > 0:
                # TODO: filter function propogate
                pass

        source.selected.on_change("indices", propogate_select_to_filter)

    # add reset range event
    def on_reset(event):
        """Range resets"""
        newx = calculate_range(plotstate, dff, "x")
        newy = calculate_range(plotstate, dff, "y")
        with p.hold(render=True):
            p.x_range.update(start=newx[0], end=newx[1])
            p.y_range.update(start=newy[0], end=newy[1])

    p.on_event("reset", on_reset)

    # zora jump
    if (plotstate.plottype == "scatter") or (plotstate.plottype == "skyplot"):
        tapcb = CustomJS(
            args=dict(source=source),
            code="""
            window.open(`https://data.sdss.org/zora/target/${source.data.sdss_id[source.inspected.indices[0]]}`, '_blank').focus();
            """,
        )
        tap = TapTool(
            behavior="inspect",
            callback=tapcb,
            gesture="doubletap",
            visible=False,  # hidden
        )
        p.add_tools(tap)


def calculate_range(plotstate, dff, axis: str = "x") -> tuple[float, float]:
    """
    Fetches a new reset-like start/end value based on the flip, log, and column.

    Note:
        This already accounts for log scaling and flipping. One simply just has to set start/end props on the range.

    Args:
        plotstate: plot variables
        dff: filtered dataframe
        axis: the axis to perform on ('x' or 'y')
    Returns:
        tuple for start/end props of range.
    """
    from state import df  # TODO: change to subset

    # bug checking
    assert axis in ("x", "y"), f"expected axis x or y but got {axis}"

    # fetch
    col = plotstate.x.value if axis == "x" else plotstate.y.value
    flip = plotstate.flipx.value if axis == "x" else plotstate.flipy.value
    log = plotstate.logx.value if axis == "x" else plotstate.logy.value

    expr = dff[col]
    if check_categorical(expr):
        expr = df[col]
        limits = (0, expr.nunique() - 1)
    else:
        if log:  # limit to > 0 for log mapping
            expr = np.log10(dff[dff[col] > 0]
                            [col])  # TODO: may cause assertion error crashes
        try:
            limits = expr.minmax()
        except RuntimeError:
            # TODO: logger.debug("dodging stride bug")
            limits = (expr.min()[()], expr.max()[()])

    # bokeh uses 10% of range as padding by default
    datarange = abs(limits[1] - limits[0])
    pad = datarange / 20
    start = limits[0]
    end = limits[1]
    if plotstate.plottype != "heatmap":
        start = start - pad
        end = end + pad
    if log:
        start = 10**start
        end = 10**end

    if not flip:
        return start, end
    else:
        return end, start


def generate_categorical_tick_formatter(
    mapping: dict[str | bool, int], ) -> CustomJSTickFormatter:
    """
    Generates a categorical tick formatter.
    Works by reversing the mapping and compiling a new JS code.

    Args:
        mapping: Pre-generated mapping of categories to integers.

    Returns:
        formatter: new formatter to perform mapping
    """
    reverseMapping = {v: k for k, v in mapping.items()}
    cjs = """
    var mapper = new Object(mapping);
    return mapper.get(tick) || ""
    """
    return CustomJSTickFormatter(args=dict(mapping=reverseMapping), code=cjs)


def generate_datamap(expr: vx.Expression) -> dict[str | bool, int]:
    """Generates a mapping for categorical data"""
    n: int = expr.nunique()
    factors: list[str | bool] = expr.unique()
    return {k: v for (k, v) in zip(factors, range(n))}


def generate_categorical_hover_formatter(plotstate, axis: str = "x"):
    """Generates tooltips for a hovertool based on current plotstate.

    Args:
        plotstate: plot variables
        axis: axis to generate for, any of 'x','y', or 'color'.
    """
    assert axis in ("x", "y", "color"), (
        f'expected axis to be "x","y", or "color" but got {axis}')
    col = getattr(plotstate, axis).value
    mapping = getattr(plotstate, f"{axis}mapping")
    if check_categorical(col):
        cjs = f"""console.log(Math.floor(value));
        return ({json.dumps(mapping)})[Math.floor(value)];"""
    else:
        cjs = """return value.toFixed(4);"""

    return CustomJSHover(code=cjs)


def generate_tooltips(plotstate: PlotState) -> str:
    """Generates tooltips for a hovertool based on current plotstate.

    Args:
        plotstate: plot variables
    """

    def generate_row(label, value):
        return f"""
            <div style="display: table-row">
                <div style="display: table-cell; color: #0D47A1; text-align: right;">
                    {label}:
                </div>
                <div style="display: table-cell;">
                    {value}
                </div>
            </div>
        """

    # define the labels and corresponding values based on plottype
    labels_values = [
        (generate_label(plotstate, axis="x"), "$snap_x{0}"),
    ]
    if plotstate.plottype != "histogram":
        labels_values.extend([
            (generate_label(plotstate, axis="y"), "$snap_y{0}"),
            (generate_label(plotstate, axis="color"), "@color{0}"),
        ])
    if plotstate.plottype == "scatter":
        labels_values.append(("sdss_id", "@sdss_id"))

    # generate the rows dynamically
    rows = "".join(
        generate_row(label, value) for label, value in labels_values)

    # construct the full HTML structure
    return (
        f"""
    <div>
        <div style="display: table; border-spacing: 2px;">
            {rows}
        </div>
    </div>""" + """
    <style>
        div.bk-tooltip-content > div > div:not(:first-child) {
            display:none !important;
        }
    </style>"""
    )  # this is a hack to stop multiple point's tips from displaying at once


def calculate_colorbar_ticks(low, high) -> list[float]:
    """Manually calculates colorbar ticks to bypas low-level Bokeh object replacement locks."""

    def get_interval(data_low, data_high, desired_n_ticks):
        """Helper to get ticks interval. Translated from AdaptiveTicker in BokehJS."""
        data_range = data_high - data_low
        ideal_interval = (data_high - data_low) / desired_n_ticks

        def extended_mantissas():
            mantissas = [1, 2, 5]
            prefix_mantissa = mantissas[-1]
            suffix_mantissa = mantissas[0]
            return [prefix_mantissa] + mantissas + [suffix_mantissa]

        def clamp(value, min_val, max_val):
            return max(min_val, min(value, max_val))

        interval_exponent = np.floor(np.log10(ideal_interval))
        ideal_magnitude = 10**interval_exponent

        candidate_mantissas = extended_mantissas()
        errors = [
            abs(desired_n_ticks - (data_range / (mantissa * ideal_magnitude)))
            for mantissa in candidate_mantissas
        ]

        best_mantissa = candidate_mantissas[np.argmin(errors)]
        interval = best_mantissa * ideal_magnitude
        return clamp(interval, 0, float("inf"))

    interval = get_interval(low, high, 6)
    return np.arange(round(low / interval) * interval, high, interval).tolist()
